<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Paralel Doğru Çizme</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #3b82f6; /* Modern mavi */
            --success-color: #22c55e; /* Modern yeşil */
            --error-color: #ef4444; /* Modern kırmızı */
            --point-color: #f43f5e; /* Modern pembe-kırmızı */
            --bg-color: #f0f9ff; /* Hafif mavi arka plan */
            --container-bg: #ffffff; /* Beyaz container */
            --text-color: #1e293b; /* Koyu gri metin */
            --border-color: #e2e8f0; /* Hafif gri border */
            --grid-color: #cbd5e1; /* Daha yumuşak grid rengi */
            --shadow-color: rgba(0, 0, 0, 0.05); /* Hafif gölge */
        }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            text-align: center;
        }
        .parallel-game-container {
            padding: 30px;
            background-color: var(--container-bg);
            border-radius: 16px;
            box-shadow: 0 8px 16px var(--shadow-color);
            max-width: 95%;
            width: 600px;
            box-sizing: border-box;
            transition: box-shadow 0.3s ease;
        }
        .parallel-game-container:hover {
            box-shadow: 0 12px 24px var(--shadow-color);
        }
        .parallel-game-title {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-size: 2em;
            font-weight: 700;
        }
        .parallel-game-description {
            font-size: 1.2em;
            margin-bottom: 25px;
            line-height: 1.7;
            color: #475569;
        }
        .parallel-game-canvas {
            border: 2px solid var(--border-color);
            border-radius: 12px;
            cursor: crosshair;
            touch-action: none;
            background-color: #fff;
            max-width: 100%;
            height: auto;
            box-shadow: 0 4px 8px var(--shadow-color);
        }
        .parallel-game-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s;
            margin: 8px;
        }
        .parallel-game-btn:hover {
            background-color: #2563eb;
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(59, 130, 246, 0.3);
        }
        .parallel-game-btn.success {
            background-color: var(--success-color);
        }
        .parallel-game-btn.success:hover {
            background-color: #16a34a;
            box-shadow: 0 4px 8px rgba(34, 197, 94, 0.3);
        }
        .parallel-game-btn.help {
            background-color: #6b7280;
        }
        .parallel-game-btn.help:hover {
            background-color: #4b5563;
            box-shadow: 0 4px 8px rgba(107, 114, 128, 0.3);
        }
        .parallel-game-message {
            margin: 20px 0;
            font-size: 1.3em;
            font-weight: 600;
            min-height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.3s ease;
        }
        .parallel-game-score {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #475569;
        }
        .parallel-game-start-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .parallel-game-activity-screen {
            display: none;
        }
        .parallel-game-footer {
            margin-top: 20px;
            font-size: 0.9em;
            color: #64748b;
        }
        /* Görselleri geliştirme: Animasyonlu geçişler ekle */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .parallel-game-container > * {
            animation: fadeIn 0.5s ease-out;
        }
    </style>
</head>
<body>
    <div class="parallel-game-container">
        <div id="startScreen" class="parallel-game-start-screen">
            <h1 class="parallel-game-title">Paralel Doğru Çizelim</h1>
            <p class="parallel-game-description">Verilen bir doğruya paralel ve belirtilen noktadan geçen başka bir doğru çizebilir misin? Hadi deneyelim!</p>
            <button id="startButton" class="parallel-game-btn">Başla</button>
            <div class="parallel-game-footer">Hazırlayan: Osman AYDOĞDU</div>
        </div>
        <div id="activityScreen" class="parallel-game-activity-screen">
            <h1 class="parallel-game-title">Paralel Doğru Çizelim</h1>
            <p class="parallel-game-description"><b>AB</b> doğrusuna paralel olacak şekilde, <b>S</b> noktasından geçen bir doğru çizin.</p>
            <div id="score" class="parallel-game-score">Puan: 0</div>
            <canvas id="drawingCanvas" class="parallel-game-canvas" width="500" height="500"></canvas>
            <div id="controls">
                <div id="message" class="parallel-game-message"></div>
                <button id="resetButton" class="parallel-game-btn">Tekrar Başlat</button>
                <button id="helpButton" class="parallel-game-btn help">Yardım</button>
            </div>
        </div>
    </div>
    <script>
        class Game {
            constructor() {
                this.canvas = document.getElementById('drawingCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.message = document.getElementById('message');
                this.scoreElement = document.getElementById('score');
                this.resetButton = document.getElementById('resetButton');
                this.helpButton = document.getElementById('helpButton');
                this.startScreen = document.getElementById('startScreen');
                this.activityScreen = document.getElementById('activityScreen');
                this.startButton = document.getElementById('startButton');
                this.gridSize = 20;
                this.isDrawing = false;
                this.startX = 0;
                this.startY = 0;
                this.refLine = null;
                this.pointS = null;
                this.score = 0;
                this.isAudioInitialized = false;
                this.synth = null;
                this.bufferCanvas = document.createElement('canvas');
                this.bufferCanvas.width = this.canvas.width;
                this.bufferCanvas.height = this.canvas.height;
                this.bufferCtx = this.bufferCanvas.getContext('2d');
                this.setupEventListeners();
            }
            async initAudio() {
                if (this.isAudioInitialized) return;
                try {
                    await Tone.start();
                    this.synth = new Tone.Synth().toDestination();
                    this.isAudioInitialized = true;
                } catch (e) {
                    console.error("Ses motoru başlatılamadı:", e);
                }
            }
            playSuccessSound() {
                if (!this.isAudioInitialized || !this.synth) return;
                this.synth.triggerAttackRelease("C5", "8n", Tone.now());
                this.synth.triggerAttackRelease("G5", "8n", Tone.now() + 0.2);
            }
            playErrorSound() {
                if (!this.isAudioInitialized || !this.synth) return;
                this.synth.triggerAttackRelease("C3", "8n");
            }
            playClickSound() {
                if (!this.isAudioInitialized) return;
                try {
                    const clickSynth = new Tone.MembraneSynth().toDestination();
                    clickSynth.triggerAttackRelease("C2", "8n");
                } catch (e) {}
            }
            initialize() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.bufferCtx.clearRect(0, 0, this.bufferCanvas.width, this.bufferCanvas.height);
                this.message.textContent = "";
                this.message.style.color = '';
                this.resetButton.className = 'parallel-game-btn';
                this.generateRandomLineAndPoint();
                this.drawStaticElements();
                this.ctx.drawImage(this.bufferCanvas, 0, 0);
            }
            generateRandomLineAndPoint() {
                const paddingCells = 3;
                const minLength = 10;
                const maxLength = 15;
                const numCellsX = Math.floor(this.canvas.width / this.gridSize);
                const numCellsY = Math.floor(this.canvas.height / this.gridSize);
                let lineIsValid = false;
                while (!lineIsValid) {
                    let startCellX = Math.floor(Math.random() * numCellsX);
                    let startCellY = Math.floor(Math.random() * numCellsY);
                    const length = Math.floor(Math.random() * (maxLength - minLength + 1)) + minLength;
                    const type = Math.floor(Math.random() * 4);
                    let dx = 0, dy = 0;
                    switch (type) {
                        case 0: dx = 1; dy = 0; break;
                        case 1: dx = 0; dy = 1; break;
                        case 2: dx = 1; dy = 1; break;
                        case 3: dx = 1; dy = -1; break;
                    }
                    if (Math.random() > 0.5) { dx *= -1; dy *= -1; }
                    let endCellX = startCellX + dx * length;
                    let endCellY = startCellY + dy * length;
                    const maxCellX = numCellsX - paddingCells;
                    const maxCellY = numCellsY - paddingCells;
                    if (startCellX >= paddingCells && startCellX < maxCellX && startCellY >= paddingCells && startCellY < maxCellY &&
                        endCellX >= paddingCells && endCellX < maxCellX && endCellY >= paddingCells && endCellY < maxCellY) {
                        lineIsValid = true;
                        this.refLine = {
                            startX: startCellX * this.gridSize,
                            startY: startCellY * this.gridSize,
                            endX: endCellX * this.gridSize,
                            endY: endCellY * this.gridSize
                        };
                    }
                }
                let sIsValid = false;
                while (!sIsValid) {
                    const sCellX = Math.floor(Math.random() * (numCellsX - 2 * paddingCells)) + paddingCells;
                    const sCellY = Math.floor(Math.random() * (numCellsY - 2 * paddingCells)) + paddingCells;
                    const sx = sCellX * this.gridSize;
                    const sy = sCellY * this.gridSize;
                    const crossProduct = (sy - this.refLine.startY) * (this.refLine.endX - this.refLine.startX) -
                                        (sx - this.refLine.startX) * (this.refLine.endY - this.refLine.startY);
                    const distToLine = Math.abs(crossProduct) / Math.hypot(this.refLine.endX - this.refLine.startX, this.refLine.endY - this.refLine.startY);
                    if (distToLine > 3 * this.gridSize) {
                        this.pointS = { x: sx, y: sy };
                        sIsValid = true;
                    }
                }
            }
            drawStaticElements() {
                this.drawGrid();
                this.drawArrow(this.refLine.startX, this.refLine.startY, this.refLine.endX, this.refLine.endY, 'black', 2, 'A', 'B');
                this.drawPointS();
            }
            drawGrid() {
                this.bufferCtx.beginPath();
                this.bufferCtx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid-color');
                this.bufferCtx.lineWidth = 0.5; // Daha ince grid için
                for (let x = 0; x <= this.canvas.width; x += this.gridSize) {
                    this.bufferCtx.moveTo(x, 0);
                    this.bufferCtx.lineTo(x, this.canvas.height);
                }
                for (let y = 0; y <= this.canvas.height; y += this.gridSize) {
                    this.bufferCtx.moveTo(0, y);
                    this.bufferCtx.lineTo(this.canvas.width, y);
                }
                this.bufferCtx.stroke();
            }
            drawPointS() {
                if (!this.pointS) return;
                const pointColor = getComputedStyle(document.documentElement).getPropertyValue('--point-color');
                this.bufferCtx.fillStyle = pointColor;
                this.bufferCtx.beginPath();
                this.bufferCtx.arc(this.pointS.x, this.pointS.y, 8, 0, 2 * Math.PI); // Daha büyük nokta
                this.bufferCtx.fill();
                this.bufferCtx.shadowColor = 'rgba(0, 0, 0, 0.2)'; // Gölge ekle
                this.bufferCtx.shadowBlur = 5;
                this.bufferCtx.fillStyle = 'black';
                this.bufferCtx.font = "bold 18px Inter";
                this.bufferCtx.textAlign = "center";
                this.bufferCtx.textBaseline = "bottom";
                this.bufferCtx.fillText("S", this.pointS.x, this.pointS.y - 10);
                this.bufferCtx.shadowBlur = 0; // Gölgeyi sıfırla
            }
            drawArrow(x1, y1, x2, y2, color, lineWidth, labelA, labelB, ctx = this.bufferCtx) {
                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.lineWidth = lineWidth;
                const length = Math.hypot(x2 - x1, y2 - y1);
                if (length < 1) return;
                const unitX = (x2 - x1) / length;
                const unitY = (y2 - y1) / length;
                const arrowExtension = 12;
                const lineStartX = x1 - unitX * arrowExtension;
                const lineStartY = y1 - unitY * arrowExtension;
                const lineEndX = x2 + unitX * arrowExtension;
                const lineEndY = y2 + unitY * arrowExtension;
                ctx.beginPath();
                ctx.moveTo(lineStartX, lineStartY);
                ctx.lineTo(lineEndX, lineEndY);
                ctx.stroke();
                const headlen = 12; // Daha büyük ok başı
                const angleEnd = Math.atan2(lineEndY - lineStartY, lineEndX - lineStartX);
                ctx.beginPath();
                ctx.moveTo(lineEndX, lineEndY);
                ctx.lineTo(lineEndX - headlen * Math.cos(angleEnd - Math.PI / 6), lineEndY - headlen * Math.sin(angleEnd - Math.PI / 6));
                ctx.moveTo(lineEndX, lineEndY);
                ctx.lineTo(lineEndX - headlen * Math.cos(angleEnd + Math.PI / 6), lineEndY - headlen * Math.sin(angleEnd + Math.PI / 6));
                ctx.stroke();
                const angleStart = Math.atan2(lineStartY - lineEndY, lineStartX - lineEndX);
                ctx.beginPath();
                ctx.moveTo(lineStartX, lineStartY);
                ctx.lineTo(lineStartX - headlen * Math.cos(angleStart - Math.PI / 6), lineStartY - headlen * Math.sin(angleStart - Math.PI / 6));
                ctx.moveTo(lineStartX, lineStartY);
                ctx.lineTo(lineStartX - headlen * Math.cos(angleStart + Math.PI / 6), lineStartY - headlen * Math.sin(angleStart + Math.PI / 6));
                ctx.stroke();
                if (labelA || labelB) {
                    const offset = 20; // Daha fazla boşluk
                    const pointRadius = 5; // Daha büyük nokta
                    ctx.font = "bold 18px Inter"; // Modern font
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    const perpX = -unitY;
                    const perpY = unitX;
                    if (labelA) {
                        ctx.beginPath();
                        ctx.arc(x1, y1, pointRadius, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillText(labelA, x1 + perpX * offset, y1 + perpY * offset);
                    }
                    if (labelB) {
                        ctx.beginPath();
                        ctx.arc(x2, y2, pointRadius, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.fillText(labelB, x2 + perpX * offset, y2 + perpY * offset);
                    }
                }
            }
            getSlope(x1, y1, x2, y2) {
                if (Math.abs(x2 - x1) < 0.001) return Infinity;
                return (y2 - y1) / (x2 - x1);
            }
            snapToGrid(coord) {
                return Math.round(coord / this.gridSize) * this.gridSize;
            }
            getRawMousePos(evt) {
                const rect = this.canvas.getBoundingClientRect();
                if (evt.changedTouches && evt.changedTouches.length > 0) {
                    return [evt.changedTouches[0].clientX - rect.left, evt.changedTouches[0].clientY - rect.top];
                }
                return [evt.clientX - rect.left, evt.clientY - rect.top];
            }
            startDrawing(e) {
                e.preventDefault();
                this.isDrawing = true;
                const [x, y] = this.getRawMousePos(e);
                this.startX = this.snapToGrid(x);
                this.startY = this.snapToGrid(y);
            }
            draw(e) {
                if (!this.isDrawing) return;
                e.preventDefault();
                const [x, y] = this.getRawMousePos(e);
                const currentX = this.snapToGrid(x);
                const currentY = this.snapToGrid(y);
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.drawImage(this.bufferCanvas, 0, 0);
                this.ctx.beginPath();
                this.ctx.moveTo(this.startX, this.startY);
                this.ctx.lineTo(currentX, currentY);
                this.ctx.strokeStyle = 'rgba(59, 130, 246, 0.6)'; // Modern yarı saydam mavi
                this.ctx.lineWidth = 3; // Daha kalın çizgi
                this.ctx.stroke();
            }
            stopDrawing(e) {
                if (!this.isDrawing) return;
                this.isDrawing = false;
                e.preventDefault();
                const [x, y] = this.getRawMousePos(e);
                const endX = this.snapToGrid(x);
                const endY = this.snapToGrid(y);
                if (this.startX === endX && this.startY === endY) {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.drawImage(this.bufferCanvas, 0, 0);
                    return;
                }
                const refSlope = this.getSlope(this.refLine.startX, this.refLine.startY, this.refLine.endX, this.refLine.endY);
                const userSlope = this.getSlope(this.startX, this.startY, endX, endY);
                let isParallel = false;
                const tolerance = 0.01;
                if (refSlope === Infinity && userSlope === Infinity) isParallel = true;
                else if (Math.abs(refSlope - userSlope) < tolerance) isParallel = true;
                const crossProduct = (this.pointS.y - this.startY) * (endX - this.startX) -
                                    (this.pointS.x - this.startX) * (endY - this.startY);
                const passesThroughS = Math.abs(crossProduct) < 1;
                const rootStyles = getComputedStyle(document.documentElement);
                const successColor = rootStyles.getPropertyValue('--success-color');
                const errorColor = rootStyles.getPropertyValue('--error-color');
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.drawImage(this.bufferCanvas, 0, 0);
                let labelC = 'C';
                let labelD = 'D';
                if (this.pointS && this.startX === this.pointS.x && this.startY === this.pointS.y) {
                    labelC = null;
                }
                if (this.pointS && endX === this.pointS.x && endY === this.pointS.y) {
                    labelD = null;
                }
                if (isParallel && passesThroughS) {
                    this.score += 10;
                    this.scoreElement.textContent = `Puan: ${this.score}`;
                    this.playSuccessSound();
                    this.message.textContent = "Harika! Doğruyu çizdiniz.";
                    this.message.style.color = successColor;
                    this.resetButton.className = 'parallel-game-btn success';
                    this.drawArrow(this.startX, this.startY, endX, endY, successColor, 3, labelC, labelD, this.ctx); // Kalınlaştır
                } else {
                    this.playErrorSound();
                    if (!isParallel) {
                        this.message.textContent = `Tekrar Deneyin. Referans doğrunun eğimi: ${refSlope.toFixed(2)}, senin doğrun: ${userSlope.toFixed(2)}.`;
                    } else {
                        this.message.textContent = "Doğru paralel ama S noktasından geçmiyor.";
                    }
                    this.message.style.color = errorColor;
                    this.drawArrow(this.startX, this.startY, endX, endY, errorColor, 3, labelC, labelD, this.ctx); // Kalınlaştır
                }
            }
            showHelp() {
                this.message.textContent = "İpucu: Paralel doğruların eğimleri eşit olmalıdır ve çizdiğiniz doğru S noktasından geçmelidir.";
                this.message.style.color = getComputedStyle(document.documentElement).getPropertyValue('--primary-color');
                this.playClickSound();
            }
            setupEventListeners() {
                this.startButton.addEventListener('click', () => {
                    this.initAudio();
                    this.playClickSound();
                    this.startScreen.style.display = 'none';
                    this.activityScreen.style.display = 'block';
                    this.initialize();
                });
                this.resetButton.addEventListener('click', () => {
                    this.playClickSound();
                    this.initialize();
                });
                this.helpButton.addEventListener('click', () => this.showHelp());
                this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));
                this.canvas.addEventListener('mousemove', (e) => this.draw(e));
                window.addEventListener('mouseup', (e) => this.stopDrawing(e));
                this.canvas.addEventListener('touchstart', (e) => this.startDrawing(e), { passive: false });
                this.canvas.addEventListener('touchmove', (e) => this.draw(e), { passive: false });
                window.addEventListener('touchend', (e) => this.stopDrawing(e));
            }
        }
        const game = new Game();
    </script>
</body>
</html>